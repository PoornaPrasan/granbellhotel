const Reservation = require('../models/Reservation');
const Room = require('../models/Room');
const Billing = require('../models/Billing');
const Report = require('../models/Report');

exports.getDailyOccupancyReport = async (req, res) => {
  try {
    const { date } = req.query;
    const reportDate = date ? new Date(date) : new Date();
    reportDate.setHours(0, 0, 0, 0);

    const startOfDay = new Date(reportDate);
    const endOfDay = new Date(reportDate);
    endOfDay.setHours(23, 59, 59, 999);

    const totalRooms = await Room.countDocuments();

    const occupiedRooms = await Reservation.countDocuments({
      checkInDate: { $lte: endOfDay },
      checkOutDate: { $gt: startOfDay },
      status: { $in: ['confirmed', 'checked-in'] }
    });

    const vacantRooms = totalRooms - occupiedRooms;

    const noShowCount = await Reservation.countDocuments({
      checkInDate: { $gte: startOfDay, $lte: endOfDay },
      status: 'no-show'
    });

    const reservationsOnDate = await Reservation.find({
      checkInDate: { $lte: endOfDay },
      checkOutDate: { $gt: startOfDay },
      status: { $nin: ['cancelled'] }
    });

    let roomRevenue = 0;
    for (const res of reservationsOnDate) {
      const totalDays = Math.ceil((res.checkOutDate - res.checkInDate) / (1000 * 60 * 60 * 24));
      const daysBefore = Math.max(0, Math.ceil((startOfDay - res.checkInDate) / (1000 * 60 * 60 * 24)));
      const daysAfter = Math.max(0, Math.ceil((res.checkOutDate - endOfDay) / (1000 * 60 * 60 * 24)));
      const daysInPeriod = Math.max(0, totalDays - daysBefore - daysAfter);

      if (daysInPeriod > 0) {
        roomRevenue += (res.totalAmount / totalDays) * daysInPeriod;
      }
    }

    const billings = await Billing.find({
      createdAt: { $gte: startOfDay, $lte: endOfDay }
    });

    const serviceRevenue = billings.reduce((sum, billing) => {
      return sum + billing.additionalCharges.reduce((chargeSum, charge) => chargeSum + charge.amount, 0);
    }, 0);

    const totalRevenue = roomRevenue + serviceRevenue;

    const reportData = {
      date: reportDate,
      totalRooms,
      occupiedRooms,
      vacantRooms,
      occupancyRate: totalRooms > 0 ? ((occupiedRooms / totalRooms) * 100).toFixed(2) : 0,
      noShowCount,
      revenue: {
        room: Math.round(roomRevenue * 100) / 100,
        services: Math.round(serviceRevenue * 100) / 100,
        total: Math.round(totalRevenue * 100) / 100
      }
    };

    const savedReport = await Report.create({
      type: 'daily_occupancy',
      generatedBy: req.user._id,
      isAutoGenerated: false,
      reportDate,
      data: reportData,
      status: 'generated'
    });

    res.json({
      success: true,
      data: reportData,
      reportId: savedReport._id
    });
  } catch (error) {
    res.status(500).json({ message: 'Server error', error: error.message });
  }
};

exports.getNoShowReport = async (req, res) => {
  try {
    const { date } = req.query;
    const reportDate = date ? new Date(date) : new Date();
    reportDate.setHours(0, 0, 0, 0);

    const startOfDay = new Date(reportDate);
    const endOfDay = new Date(reportDate);
    endOfDay.setHours(23, 59, 59, 999);

    const noShowReservations = await Reservation.find({
      checkInDate: { $gte: startOfDay, $lte: endOfDay },
      status: 'no-show'
    }).populate('roomId', 'type number').populate('customerId', 'name email');

    const noShowsWithBilling = await Promise.all(
      noShowReservations.map(async (reservation) => {
        const billing = await Billing.findOne({ reservationId: reservation._id });

        const noShowCharge = reservation.depositAmount || (reservation.totalAmount * 0.5);

        return {
          reservationId: reservation._id,
          customerName: reservation.customerName,
          customerEmail: reservation.customerEmail,
          customerPhone: reservation.customerPhone,
          roomType: reservation.roomId?.type || 'N/A',
          roomNumber: reservation.roomNumber,
          checkInDate: reservation.checkInDate,
          noShowCharge: Math.round(noShowCharge * 100) / 100,
          paymentStatus: billing?.paymentStatus || 'pending',
          paidAmount: billing?.paidAmount || 0
        };
      })
    );

    const totalNoShows = noShowsWithBilling.length;
    const totalCharges = noShowsWithBilling.reduce((sum, item) => sum + item.noShowCharge, 0);
    const totalPaid = noShowsWithBilling.reduce((sum, item) => sum + item.paidAmount, 0);

    const reportData = {
      date: reportDate,
      totalNoShows,
      totalCharges: Math.round(totalCharges * 100) / 100,
      totalPaid: Math.round(totalPaid * 100) / 100,
      outstanding: Math.round((totalCharges - totalPaid) * 100) / 100,
      noShows: noShowsWithBilling
    };

    const savedReport = await Report.create({
      type: 'no_show',
      generatedBy: req.user._id,
      isAutoGenerated: false,
      reportDate,
      data: reportData,
      status: 'generated'
    });

    res.json({
      success: true,
      data: reportData,
      reportId: savedReport._id
    });
  } catch (error) {
    res.status(500).json({ message: 'Server error', error: error.message });
  }
};

exports.getHotelOccupancyReport = async (req, res) => {
  try {
    const { startDate, endDate } = req.query;

    if (!startDate || !endDate) {
      return res.status(400).json({ message: 'Please provide startDate and endDate' });
    }

    const start = new Date(startDate);
    const end = new Date(endDate);
    start.setHours(0, 0, 0, 0);
    end.setHours(23, 59, 59, 999);

    const rooms = await Room.find();
    const roomsByType = {};

    rooms.forEach(room => {
      if (!roomsByType[room.type]) {
        roomsByType[room.type] = {
          type: room.type,
          totalRooms: 0,
          capacity: room.capacity
        };
      }
      roomsByType[room.type].totalRooms++;
    });

    const reservations = await Reservation.find({
      checkInDate: { $lte: end },
      checkOutDate: { $gt: start },
      status: { $nin: ['cancelled'] }
    }).populate('roomId', 'type');

    const occupancyByType = {};

    Object.keys(roomsByType).forEach(type => {
      occupancyByType[type] = {
        ...roomsByType[type],
        currentBookings: 0,
        pastBookings: 0,
        projectedBookings: 0,
        occupancyRate: 0
      };
    });

    const now = new Date();

    reservations.forEach(res => {
      const roomType = res.roomId?.type;
      if (!roomType || !occupancyByType[roomType]) return;

      if (res.checkOutDate <= now) {
        occupancyByType[roomType].pastBookings++;
      } else if (res.checkInDate > now) {
        occupancyByType[roomType].projectedBookings++;
      } else {
        occupancyByType[roomType].currentBookings++;
      }
    });

    const totalDays = Math.ceil((end - start) / (1000 * 60 * 60 * 24));

    Object.keys(occupancyByType).forEach(type => {
      const typeData = occupancyByType[type];
      const totalBookings = typeData.currentBookings + typeData.pastBookings + typeData.projectedBookings;
      const maxPossibleBookings = typeData.totalRooms * totalDays;
      typeData.occupancyRate = maxPossibleBookings > 0
        ? ((totalBookings / maxPossibleBookings) * 100).toFixed(2)
        : 0;
    });

    const reportData = {
      dateRange: {
        startDate: start,
        endDate: end
      },
      occupancyByRoomType: Object.values(occupancyByType),
      totalRooms: rooms.length,
      overallOccupancyRate: rooms.length > 0
        ? (reservations.length / (rooms.length * totalDays) * 100).toFixed(2)
        : 0
    };

    const savedReport = await Report.create({
      type: 'hotel_occupancy',
      generatedBy: req.user._id,
      isAutoGenerated: false,
      reportDate: new Date(),
      dateRange: { startDate: start, endDate: end },
      data: reportData,
      status: 'generated'
    });

    res.json({
      success: true,
      data: reportData,
      reportId: savedReport._id
    });
  } catch (error) {
    res.status(500).json({ message: 'Server error', error: error.message });
  }
};

exports.getFinancialReport = async (req, res) => {
  try {
    const { startDate, endDate, groupBy = 'daily' } = req.query;

    if (!startDate || !endDate) {
      return res.status(400).json({ message: 'Please provide startDate and endDate' });
    }

    const start = new Date(startDate);
    const end = new Date(endDate);
    start.setHours(0, 0, 0, 0);
    end.setHours(23, 59, 59, 999);

    const reservations = await Reservation.find({
      checkInDate: { $lte: end },
      checkOutDate: { $gt: start },
      status: { $nin: ['cancelled'] }
    }).populate('roomId', 'type');

    const billings = await Billing.find({
      createdAt: { $gte: start, $lte: end }
    });

    const revenueByRoomType = {};
    const revenueByPaymentMethod = {
      credit_card: 0,
      cash: 0,
      pending: 0
    };

    let totalRoomRevenue = 0;

    reservations.forEach(res => {
      const roomType = res.roomId?.type || 'Unknown';
      if (!revenueByRoomType[roomType]) {
        revenueByRoomType[roomType] = 0;
      }
      revenueByRoomType[roomType] += res.totalAmount;
      totalRoomRevenue += res.totalAmount;

      if (revenueByPaymentMethod[res.paymentMethod] !== undefined) {
        revenueByPaymentMethod[res.paymentMethod] += res.totalAmount;
      }
    });

    const additionalRevenueByCategory = {
      room_service: 0,
      restaurant: 0,
      laundry: 0,
      minibar: 0,
      other: 0
    };

    let totalAdditionalRevenue = 0;

    billings.forEach(billing => {
      billing.additionalCharges.forEach(charge => {
        if (additionalRevenueByCategory[charge.category] !== undefined) {
          additionalRevenueByCategory[charge.category] += charge.amount;
        }
        totalAdditionalRevenue += charge.amount;
      });

      if (billing.paymentMethod && revenueByPaymentMethod[billing.paymentMethod] !== undefined) {
        const chargesTotal = billing.additionalCharges.reduce((sum, charge) => sum + charge.amount, 0);
        revenueByPaymentMethod[billing.paymentMethod] += chargesTotal;
      }
    });

    const outstandingBalances = await Billing.aggregate([
      {
        $match: {
          paymentStatus: { $in: ['pending', 'partial'] }
        }
      },
      {
        $group: {
          _id: null,
          totalOutstanding: { $sum: { $subtract: ['$totalAmount', '$paidAmount'] } }
        }
      }
    ]);

    const outstandingAmount = outstandingBalances.length > 0
      ? outstandingBalances[0].totalOutstanding
      : 0;

    const reportData = {
      dateRange: {
        startDate: start,
        endDate: end
      },
      totalRevenue: Math.round((totalRoomRevenue + totalAdditionalRevenue) * 100) / 100,
      roomRevenue: {
        total: Math.round(totalRoomRevenue * 100) / 100,
        byRoomType: Object.entries(revenueByRoomType).map(([type, amount]) => ({
          type,
          amount: Math.round(amount * 100) / 100
        }))
      },
      additionalRevenue: {
        total: Math.round(totalAdditionalRevenue * 100) / 100,
        byCategory: Object.entries(additionalRevenueByCategory).map(([category, amount]) => ({
          category,
          amount: Math.round(amount * 100) / 100
        }))
      },
      revenueByPaymentMethod: Object.entries(revenueByPaymentMethod).map(([method, amount]) => ({
        method,
        amount: Math.round(amount * 100) / 100
      })),
      outstandingBalances: Math.round(outstandingAmount * 100) / 100
    };

    const savedReport = await Report.create({
      type: 'financial',
      generatedBy: req.user._id,
      isAutoGenerated: false,
      reportDate: new Date(),
      dateRange: { startDate: start, endDate: end },
      data: reportData,
      status: 'generated'
    });

    res.json({
      success: true,
      data: reportData,
      reportId: savedReport._id
    });
  } catch (error) {
    res.status(500).json({ message: 'Server error', error: error.message });
  }
};

exports.getCheckoutStatement = async (req, res) => {
  try {
    const { reservationId } = req.params;

    if (!reservationId) {
      return res.status(400).json({ message: 'Please provide reservationId' });
    }

    const reservation = await Reservation.findById(reservationId)
      .populate('customerId', 'name email phone')
      .populate('roomId', 'type number pricePerNight');

    if (!reservation) {
      return res.status(404).json({ message: 'Reservation not found' });
    }

    if (req.user.role === 'customer' && reservation.customerId._id.toString() !== req.user._id.toString()) {
      return res.status(403).json({ message: 'Not authorized to view this statement' });
    }

    if (req.user.role === 'travel_company' && !reservation.isCompanyBooking) {
      return res.status(403).json({ message: 'Not authorized to view this statement' });
    }

    if (req.user.role === 'travel_company' && reservation.companyId?.toString() !== req.user._id.toString()) {
      return res.status(403).json({ message: 'Not authorized to view this statement' });
    }

    const billing = await Billing.findOne({ reservationId: reservation._id });

    const numberOfNights = Math.ceil((reservation.checkOutDate - reservation.checkInDate) / (1000 * 60 * 60 * 24));
    const roomCharges = reservation.totalAmount;

    const itemizedCharges = [
      {
        description: `${reservation.roomId?.type || 'Room'} - ${numberOfNights} night(s)`,
        quantity: numberOfNights,
        unitPrice: reservation.roomId?.pricePerNight || (roomCharges / numberOfNights),
        amount: roomCharges
      }
    ];

    let additionalChargesTotal = 0;
    if (billing && billing.additionalCharges.length > 0) {
      billing.additionalCharges.forEach(charge => {
        itemizedCharges.push({
          description: `${charge.category.replace('_', ' ').toUpperCase()} - ${charge.description}`,
          quantity: 1,
          unitPrice: charge.amount,
          amount: charge.amount
        });
        additionalChargesTotal += charge.amount;
      });
    }

    const subtotal = roomCharges + additionalChargesTotal;
    const taxRate = 0.1;
    const taxAmount = subtotal * taxRate;
    const totalAmount = subtotal + taxAmount;

    const statementData = {
      reservationId: reservation._id,
      customerName: reservation.customerName,
      customerEmail: reservation.customerEmail,
      customerPhone: reservation.customerPhone,
      roomType: reservation.roomId?.type || 'N/A',
      roomNumber: reservation.roomNumber,
      checkInDate: reservation.checkInDate,
      checkOutDate: reservation.checkOutDate,
      numberOfNights,
      itemizedCharges: itemizedCharges.map(charge => ({
        ...charge,
        unitPrice: Math.round(charge.unitPrice * 100) / 100,
        amount: Math.round(charge.amount * 100) / 100
      })),
      subtotal: Math.round(subtotal * 100) / 100,
      tax: Math.round(taxAmount * 100) / 100,
      totalAmount: Math.round(totalAmount * 100) / 100,
      paidAmount: billing?.paidAmount || 0,
      balanceDue: Math.round((totalAmount - (billing?.paidAmount || 0)) * 100) / 100,
      paymentMethod: reservation.paymentMethod,
      paymentStatus: billing?.paymentStatus || 'pending',
      generatedAt: new Date()
    };

    const savedReport = await Report.create({
      type: 'checkout_statement',
      generatedBy: req.user._id,
      isAutoGenerated: false,
      reportDate: new Date(),
      data: statementData,
      status: 'generated'
    });

    res.json({
      success: true,
      data: statementData,
      reportId: savedReport._id
    });
  } catch (error) {
    res.status(500).json({ message: 'Server error', error: error.message });
  }
};

exports.getDailyReport = async (req, res) => {
  try {
    const { date } = req.query;
    const reportDate = date ? new Date(date) : new Date();

    const startOfDay = new Date(reportDate.setHours(0, 0, 0, 0));
    const endOfDay = new Date(reportDate.setHours(23, 59, 59, 999));

    const totalRooms = await Room.countDocuments();
    const occupiedRooms = await Room.countDocuments({ status: 'occupied' });

    const reservationsOnDate = await Reservation.find({
      checkInDate: { $lte: endOfDay },
      checkOutDate: { $gte: startOfDay },
      status: { $nin: ['cancelled'] }
    });

    const newReservations = await Reservation.countDocuments({
      createdAt: { $gte: startOfDay, $lte: endOfDay }
    });

    const checkedIn = await Reservation.countDocuments({
      checkInDate: { $gte: startOfDay, $lte: endOfDay },
      status: 'checked-in'
    });

    const checkedOut = await Reservation.countDocuments({
      checkOutDate: { $gte: startOfDay, $lte: endOfDay },
      status: 'checked-out'
    });

    const cancelled = await Reservation.countDocuments({
      updatedAt: { $gte: startOfDay, $lte: endOfDay },
      status: 'cancelled'
    });

    const noShows = await Reservation.countDocuments({
      checkInDate: { $gte: startOfDay, $lte: endOfDay },
      status: 'no-show'
    });

    const roomRevenue = reservationsOnDate.reduce((sum, res) => {
      const days = Math.ceil((res.checkOutDate - res.checkInDate) / (1000 * 60 * 60 * 24));
      return sum + (res.totalAmount / days);
    }, 0);

    const billings = await Billing.find({
      createdAt: { $gte: startOfDay, $lte: endOfDay }
    });

    const additionalRevenue = billings.reduce((sum, billing) => {
      return sum + billing.additionalCharges.reduce((chargeSum, charge) => chargeSum + charge.amount, 0);
    }, 0);

    const report = {
      date: startOfDay,
      occupancy: {
        total: totalRooms,
        occupied: occupiedRooms,
        percentage: totalRooms > 0 ? (occupiedRooms / totalRooms) * 100 : 0
      },
      revenue: {
        rooms: roomRevenue,
        additional: additionalRevenue,
        total: roomRevenue + additionalRevenue
      },
      reservations: {
        new: newReservations,
        checkedIn,
        checkedOut,
        cancelled,
        noShows
      }
    };

    res.json({
      success: true,
      data: report
    });
  } catch (error) {
    res.status(500).json({ message: 'Server error', error: error.message });
  }
};

exports.getMonthlyReport = async (req, res) => {
  try {
    const { year, month } = req.query;
    const reportYear = year ? parseInt(year) : new Date().getFullYear();
    const reportMonth = month ? parseInt(month) : new Date().getMonth() + 1;

    const startDate = new Date(reportYear, reportMonth - 1, 1);
    const endDate = new Date(reportYear, reportMonth, 0, 23, 59, 59, 999);

    const totalRooms = await Room.countDocuments();

    const reservations = await Reservation.find({
      $or: [
        { checkInDate: { $gte: startDate, $lte: endDate } },
        { checkOutDate: { $gte: startDate, $lte: endDate } },
        {
          checkInDate: { $lte: startDate },
          checkOutDate: { $gte: endDate }
        }
      ]
    });

    const totalRevenue = reservations
      .filter(res => res.status !== 'cancelled')
      .reduce((sum, res) => sum + res.totalAmount, 0);

    const billings = await Billing.find({
      createdAt: { $gte: startDate, $lte: endDate }
    });

    const additionalRevenue = billings.reduce((sum, billing) => {
      return sum + billing.additionalCharges.reduce((chargeSum, charge) => chargeSum + charge.amount, 0);
    }, 0);

    const avgOccupancy = reservations.filter(res => res.status !== 'cancelled').length / totalRooms;

    const report = {
      year: reportYear,
      month: reportMonth,
      summary: {
        totalReservations: reservations.length,
        confirmedReservations: reservations.filter(res => res.status === 'confirmed').length,
        checkedIn: reservations.filter(res => res.status === 'checked-in').length,
        checkedOut: reservations.filter(res => res.status === 'checked-out').length,
        cancelled: reservations.filter(res => res.status === 'cancelled').length,
        noShows: reservations.filter(res => res.status === 'no-show').length,
        averageOccupancy: avgOccupancy
      },
      revenue: {
        rooms: totalRevenue,
        additional: additionalRevenue,
        total: totalRevenue + additionalRevenue
      }
    };

    res.json({
      success: true,
      data: report
    });
  } catch (error) {
    res.status(500).json({ message: 'Server error', error: error.message });
  }
};

exports.getRevenueReport = async (req, res) => {
  try {
    const { startDate, endDate } = req.query;

    if (!startDate || !endDate) {
      return res.status(400).json({ message: 'Please provide startDate and endDate' });
    }

    const start = new Date(startDate);
    const end = new Date(endDate);

    const reservations = await Reservation.find({
      checkInDate: { $gte: start, $lte: end },
      status: { $nin: ['cancelled'] }
    }).populate('roomId', 'type');

    const billings = await Billing.find({
      createdAt: { $gte: start, $lte: end }
    });

    const roomTypeRevenue = {};
    reservations.forEach(res => {
      const roomType = res.roomId.type;
      if (!roomTypeRevenue[roomType]) {
        roomTypeRevenue[roomType] = 0;
      }
      roomTypeRevenue[roomType] += res.totalAmount;
    });

    const additionalChargesBreakdown = {
      room_service: 0,
      restaurant: 0,
      laundry: 0,
      minibar: 0,
      other: 0
    };

    billings.forEach(billing => {
      billing.additionalCharges.forEach(charge => {
        additionalChargesBreakdown[charge.category] += charge.amount;
      });
    });

    const totalRoomRevenue = Object.values(roomTypeRevenue).reduce((sum, val) => sum + val, 0);
    const totalAdditionalRevenue = Object.values(additionalChargesBreakdown).reduce((sum, val) => sum + val, 0);

    const report = {
      period: {
        start,
        end
      },
      roomRevenue: {
        byType: roomTypeRevenue,
        total: totalRoomRevenue
      },
      additionalRevenue: {
        breakdown: additionalChargesBreakdown,
        total: totalAdditionalRevenue
      },
      totalRevenue: totalRoomRevenue + totalAdditionalRevenue
    };

    res.json({
      success: true,
      data: report
    });
  } catch (error) {
    res.status(500).json({ message: 'Server error', error: error.message });
  }
};
